#!/bin/sh /usr/share/dpatch/dpatch-run
## 901-file-elf.dpatch by Alessandro Rubini <rubini@gnudd.com>
##
## DP: Revert ELF file-reading (closes: #345089).

@DPATCH@

diff -Naurp file-4.23.orig/src/readelf.c file-4.23/src/readelf.c
--- file-4.23.orig/src/readelf.c	2007-12-27 16:30:52.000000000 +0000
+++ file-4.23/src/readelf.c	2008-01-12 17:48:48.000000000 +0000
@@ -919,29 +919,30 @@ file_tryelf(struct magic_set *ms, int fd
 	off_t fsize;
 	int flags = 0;
 
-	/*
-	 * If we cannot seek, it must be a pipe, socket or fifo.
-	 */
-	if((lseek(fd, (off_t)0, SEEK_SET) == (off_t)-1) && (errno == ESPIPE))
-		fd = file_pipe2file(ms, fd, buf, nbytes);
-
-	if (fstat(fd, &st) == -1) {
-  		file_badread(ms);
-		return -1;
-	}
-	fsize = st.st_size;
 
 	/*
 	 * ELF executables have multiple section headers in arbitrary
 	 * file locations and thus file(1) cannot determine it from easily.
 	 * Instead we traverse thru all section headers until a symbol table
 	 * one is found or else the binary is stripped.
+	 * Return immediately if it's not ELF (so we avoid pipe2file unless needed).
 	 */
 	if (buf[EI_MAG0] != ELFMAG0
 	    || (buf[EI_MAG1] != ELFMAG1 && buf[EI_MAG1] != OLFMAG1)
 	    || buf[EI_MAG2] != ELFMAG2 || buf[EI_MAG3] != ELFMAG3)
 	    return 0;
 
+	/*
+	 * If we cannot seek, it must be a pipe, socket or fifo.
+	 */
+	if((lseek(fd, (off_t)0, SEEK_SET) == (off_t)-1) && (errno == ESPIPE))
+		fd = file_pipe2file(ms, fd, buf, nbytes);
+
+	if (fstat(fd, &st) == -1) {
+  		file_badread(ms);
+		return -1;
+	}
+	fsize = st.st_size;
 
 	class = buf[EI_CLASS];
 
